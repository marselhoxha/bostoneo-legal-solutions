import { Component, OnInit, OnDestroy, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

import { AIDocumentService, DocumentGenerationRequest } from '../../services/ai-document.service';
import { Key } from '../../../../../../enum/key.enum';

@Component({
  selector: 'app-document-editor',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './document-editor.component.html',
  styleUrls: ['./document-editor.component.scss']
})
export class DocumentEditorComponent implements OnInit, OnDestroy {
  private destroy$ = new Subject<void>();
  
  templateId: number = 0;
  documentContent: string = '';
  isGenerating: boolean = false;
  isEditing: boolean = false;
  generationProgress: number = 0;
  errorMessage: string = '';
  selectedCaseId: string = '';
  availableCases: any[] = [];
  
  // Template properties
  currentTemplate: any = null;
  
  // Expose Object and Math for template use
  Object = Object;
  Math = Math;

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private documentService: AIDocumentService,
    private cdr: ChangeDetectorRef
  ) {}

  ngOnInit(): void {
    this.templateId = Number(this.route.snapshot.params['templateId']);
    this.loadTemplate();
    this.loadAvailableCases();
    this.subscribeToProgress();
    this.checkAuthenticationStatus();
  }

  private checkAuthenticationStatus(): void {
    const token = this.getValidAuthToken();
    if (!token) {
      // Don't show error immediately, let user interact first
    }
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  private subscribeToProgress(): void {
    this.documentService.generationProgress
      .pipe(takeUntil(this.destroy$))
      .subscribe(progress => {
        this.generationProgress = progress;
      });
  }

  private loadTemplate(): void {
    // Use the document service to get the specific template
    this.documentService.getTemplate(this.templateId)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (template) => {
          this.currentTemplate = template;

          // Use the template content from database, or create a basic structure
          this.documentContent = template.templateContent || this.createBasicTemplate(template);

          this.cdr.detectChanges();
        },
        error: (error) => {
          console.error('❌ Error loading template:', error);
          this.errorMessage = 'Failed to load template';
          this.documentContent = this.createFallbackTemplate();
          this.cdr.detectChanges();
        }
      });
  }

  private createBasicTemplate(template: any): string {
    // Create a basic template structure based on the template info
    const templateType = template.category || 'DOCUMENT';
    const practiceArea = template.practiceArea || 'Legal';
    
    return `# ${template.name}
## ${template.description}

**Practice Area:** ${practiceArea}
**Category:** ${templateType}
**Jurisdiction:** ${template.jurisdiction || 'Massachusetts'}

---

**CASE INFORMATION**
- Client Name: [CLIENT_NAME]
- Case Number: [CASE_NUMBER]
- Filing Date: [FILING_DATE]
- Court: [COURT_NAME]

---

**DOCUMENT CONTENT**

This document will be generated using AI based on your case information and the selected template.

**Key Variables:**
- Client Name: [CLIENT_NAME]
- Case Number: [CASE_NUMBER] 
- Case Type: [CASE_TYPE]
- Filing Date: [FILING_DATE]
- Court Name: [COURT_NAME]
- Attorney Name: [ATTORNEY_NAME]

---

**Instructions:**
1. Select a case from the dropdown above
2. Click "Generate with AI" to create the document
3. The AI will populate all fields with your case data
4. Review and edit the generated content as needed

---

Generated by: [ATTORNEY_NAME]
Date: [CURRENT_DATE]
Case: [CASE_NUMBER]`;
  }

  private createFallbackTemplate(): string {
    return `# Legal Document Template

**CASE INFORMATION**
- Client Name: [CLIENT_NAME]
- Case Number: [CASE_NUMBER]
- Filing Date: [FILING_DATE]

## DOCUMENT CONTENT

This is a fallback template. Please select a case and click "Generate with AI" to create your document.

---

Generated Date: [CURRENT_DATE]`;
  }

  generateDocument(): void {
    this.isGenerating = true;
    this.errorMessage = '';
    
    const selectedCase = this.getSelectedCase();
    if (!selectedCase) {
      this.errorMessage = 'Please select a case before generating document';
      this.isGenerating = false;
      return;
    }
    
    // Extract template variables for AI generation
    const variables = this.extractVariables();
    
    const request: DocumentGenerationRequest = {
      templateId: this.templateId,
      variables: variables,
      outputFormat: 'HTML',
      caseId: parseInt(selectedCase.id) // Use selected case ID
    };

    this.documentService.generateDocument(request)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (response) => {
          if (response.content) {
            // Update document with AI-generated content and clean up placeholders
            this.documentContent = this.cleanupPlaceholders(response.content);
            // Switch to preview mode to show formatted content
            this.isEditing = false;
          } else {
            this.updateDocumentWithAIResponse(response);
          }
          this.isGenerating = false;
          this.cdr.detectChanges(); // Force change detection
        },
        error: (error) => {
          console.error('Error generating document:', error);
          this.errorMessage = 'AI service temporarily unavailable. Trying fallback...';
          
          // Fallback: Use direct endpoint
          this.generateWithTestEndpoint();
        }
      });
  }

  private extractVariables(): { [key: string]: any } {
    const selectedCase = this.getSelectedCase();
    
    if (!selectedCase) {
      // Fallback if no case is selected
      return {
        client_name: 'Client Name',
        case_number: 'CASE-NUMBER',
        case_type: 'General Legal',
        case_background: 'Please select a case to generate document with specific details',
        attorney_name: 'Attorney Name',
        attorney_title: 'Attorney for Client'
      };
    }

    // Map case data to template variables - leave missing fields blank instead of placeholders
    const caseVariables = {
      // Basic case information
      client_name: selectedCase.clientName || '',
      case_number: selectedCase.caseNumber || '',
      case_type: selectedCase.caseType || selectedCase.type || '',
      case_title: selectedCase.title || '',
      
      // Contact information
      client_email: selectedCase.clientEmail || '',
      client_phone: selectedCase.clientPhone || '',
      client_address: selectedCase.clientAddress || '',
      
      // Case details
      case_description: selectedCase.description || '',
      case_status: selectedCase.status || '',
      case_priority: selectedCase.priority || '',
      
      // Court information
      county_name: selectedCase.countyName || '',
      courtroom: selectedCase.courtroom || '',
      judge_name: selectedCase.judgeName || '',
      
      // Important dates (format them properly or leave blank)
      filing_date: selectedCase.filingDate ? this.formatDate(selectedCase.filingDate) : '',
      next_hearing: selectedCase.nextHearing ? this.formatDate(selectedCase.nextHearing) : '',
      trial_date: selectedCase.trialDate ? this.formatDate(selectedCase.trialDate) : '',
      
      // Financial information
      hourly_rate: selectedCase.hourlyRate || '',
      total_hours: selectedCase.totalHours || '',
      total_amount: selectedCase.totalAmount || '',
      payment_status: selectedCase.paymentStatus || '',
      
      // Template-specific variables based on case type
      case_background: this.generateCaseBackground(selectedCase),
      legal_standard: this.generateLegalStandard(selectedCase),
      legal_analysis: this.generateLegalAnalysis(selectedCase),
      
      // Attorney information (leave blank if not configured)
      attorney_name: '', // User should configure this
      attorney_title: selectedCase.clientName ? `Attorney for ${selectedCase.clientName}` : '',
      
      // Additional placeholders for templates
      defendant_name: selectedCase.clientName || '',
      plaintiff_name: '', // Leave blank - user can specify
      petitioner_name: selectedCase.clientName || '',
      beneficiary_name: '', // Leave blank for user input
      relationship: '', // Leave blank for user input
      
      // Current date for document generation
      current_date: new Date().toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
      }),
      submission_date: new Date().toISOString().split('T')[0],
      
      // Additional common template fields
      complaint_body: '', // Leave blank for AI generation
      motion_body: '', // Leave blank for AI generation
      docket_number: selectedCase.caseNumber || '',
      bbo_number: '', // Bar number - leave blank for user configuration
      
      // Template-specific mappings based on common legal document fields
      ...(this.getTemplateSpecificFields(selectedCase))
    };

    return caseVariables;
  }

  private generateCaseBackground(selectedCase: any): string {
    const filingDate = selectedCase.filingDate ? new Date(selectedCase.filingDate).toLocaleDateString() : 'an undetermined date';
    const caseType = selectedCase.caseType || selectedCase.type || 'legal matter';
    
    return `${caseType} case filed on ${filingDate}. ${selectedCase.description || 'Case involves legal matter requiring professional representation.'}`;
  }

  private generateLegalStandard(selectedCase: any): string {
    const caseType = selectedCase.caseType || selectedCase.type || '';
    
    switch (caseType.toUpperCase()) {
      case 'CRIMINAL':
        return 'Massachusetts Rules of Criminal Procedure';
      case 'FAMILY':
        return 'Massachusetts General Laws Chapter 208 (Divorce and Family Law)';
      case 'IMMIGRATION':
        return 'Immigration and Nationality Act and applicable federal regulations';
      case 'PERSONAL_INJURY':
        return 'Massachusetts negligence law and tort liability standards';
      case 'REAL_ESTATE':
        return 'Massachusetts Real Estate Law and conveyancing standards';
      case 'BUSINESS':
      case 'CORPORATE':
        return 'Massachusetts Business Corporation Act and commercial law';
      case 'INTELLECTUAL_PROPERTY':
        return 'Federal Patent and Trademark Law, Copyright Act';
      case 'EMPLOYMENT_LITIGATION':
        return 'Massachusetts Fair Employment Practices Act';
      default:
        return 'Massachusetts Rules of Civil Procedure';
    }
  }

  private generateLegalAnalysis(selectedCase: any): string {
    const caseType = selectedCase.caseType || selectedCase.type || '';
    const description = selectedCase.description || '';
    const clientName = selectedCase.clientName || 'the client';
    
    // Generate case-type specific legal analysis
    switch (caseType.toUpperCase()) {
      case 'CRIMINAL':
        return `Defense strategy for ${clientName} requires thorough examination of evidence and procedural compliance. ${description}`;
      case 'FAMILY':
        return `Family law matter involving ${clientName} requires consideration of applicable Massachusetts statutes and family court procedures. ${description}`;
      case 'IMMIGRATION':
        return `Immigration case for ${clientName} involves federal immigration law and USCIS procedures. ${description}`;
      case 'PERSONAL_INJURY':
        return `Personal injury claim for ${clientName} requires establishment of negligence and damages. ${description}`;
      default:
        return `Legal matter for ${clientName} requires thorough analysis under applicable Massachusetts law. ${description}`;
    }
  }

  private formatDate(dateString: string): string {
    if (!dateString) return '';
    
    try {
      const date = new Date(dateString);
      return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
    } catch (error) {
      return dateString; // Return original if formatting fails
    }
  }

  private getTemplateSpecificFields(selectedCase: any): { [key: string]: any } {
    const caseType = selectedCase.caseType || selectedCase.type || '';
    
    // Return case-type specific fields
    switch (caseType.toUpperCase()) {
      case 'IMMIGRATION':
        return {
          petitioner_address: selectedCase.clientAddress || '',
          petitioner_dob: '', // Leave blank for user input
          petitioner_country: '', // Leave blank for user input
          beneficiary_address: '', // Leave blank for user input
          beneficiary_dob: '', // Leave blank for user input
          petition_grounds: '', // Leave blank for AI generation
          supporting_docs: '', // Leave blank for AI generation
          priority_date: selectedCase.filingDate ? this.formatDate(selectedCase.filingDate) : ''
        };
      
      case 'FAMILY':
        return {
          plaintiff_address: selectedCase.clientAddress || '',
          defendant_address: '', // Leave blank for user input
          marriage_date: '', // Leave blank for user input
          marriage_location: '', // Leave blank for user input
          children_names: '', // Leave blank for user input
          custody_request: '', // Leave blank for AI generation
          support_request: '', // Leave blank for AI generation
          property_division: '' // Leave blank for AI generation
        };
      
      case 'CRIMINAL':
        return {
          criminal_charges: selectedCase.description || '',
          booking_number: '', // Leave blank
          arrest_date: '', // Leave blank
          probable_cause: '' // Leave blank for AI generation
        };
      
      default:
        return {
          additional_parties: '', // Leave blank
          contract_date: '', // Leave blank
          damages_sought: '', // Leave blank
          relief_requested: '' // Leave blank for AI generation
        };
    }
  }

  private updateDocumentWithAIResponse(response: any): void {
    // Update document content with AI-generated text
    this.documentContent = this.documentContent
      .replace('[DEFENDANT_NAME]', 'John Doe')
      .replace('[CASE_BACKGROUND]', response.case_background || 'AI-generated case background')
      .replace('[LEGAL_STANDARD]', response.legal_standard || 'AI-generated legal standard')
      .replace('[LEGAL_ANALYSIS]', response.legal_analysis || 'AI-generated legal analysis')
      .replace('[ATTORNEY_NAME]', 'Attorney Name')
      .replace('[ATTORNEY_TITLE]', 'Attorney for Defendant');
  }

  private generateWithTestEndpoint(): void {
    const selectedCase = this.getSelectedCase();
    if (!selectedCase) {
      this.errorMessage = 'Please select a case before generating document';
      this.isGenerating = false;
      return;
    }

    // Extract template variables for AI generation
    const variables = this.extractVariables();

    const request = {
      templateId: this.templateId,
      variables: variables,
      outputFormat: 'HTML',
      caseId: parseInt(selectedCase.id)
    };

    fetch('http://localhost:8085/api/ai/documents/generate', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify(request)
    })
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      if (data.content) {
        // Replace the document content with AI-generated content
        this.documentContent = this.cleanupPlaceholders(data.content);
        // Switch to preview mode after generation
        this.isEditing = false;
      } else if (data.status === 'COMPLETED' && data.documentUrl) {
        // Handle successful generation with document URL
        this.errorMessage = 'Document generated successfully! (Backend integration in progress)';
      } else {
        throw new Error('Invalid response from backend AI service');
      }
      this.isGenerating = false;
      this.cdr.detectChanges();
    })
    .catch(error => {
      console.error('Error with backend AI endpoint:', error);
      this.errorMessage = `Backend AI service error: ${error.message}. Please check if backend is running on port 8085.`;
      this.isGenerating = false;
      this.cdr.detectChanges();
    })
    .finally(() => {
      this.isGenerating = false;
      this.cdr.detectChanges();
    });
  }

  saveDocument(): void {
    if (!this.documentContent.trim()) {
      this.errorMessage = 'Cannot save empty document';
      return;
    }

    // Check for valid authentication token
    const token = this.getValidAuthToken();
    if (!token) {
      this.errorMessage = 'Please log in again to save documents';
      return;
    }

    const selectedCase = this.getSelectedCase();
    
    const saveRequest = {
      templateId: this.templateId,
      content: this.documentContent,
      title: `Generated Document - Template ${this.templateId}`,
      caseId: selectedCase ? parseInt(selectedCase.id) : null,
      format: 'HTML',
      metadata: {
        generatedAt: new Date().toISOString(),
        templateId: this.templateId,
        caseInfo: selectedCase
      }
    };

    fetch('http://localhost:8085/api/ai/documents/save', {
      method: 'POST',
      headers: this.createAuthHeaders(token),
      body: JSON.stringify(saveRequest)
    })
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .then(() => {
      // Show success message temporarily
      const originalError = this.errorMessage;
      this.errorMessage = '✅ Document saved successfully!';
      setTimeout(() => {
        this.errorMessage = originalError;
      }, 3000);
    })
    .catch(error => {
      console.error('❌ Error saving document:', error);
      this.errorMessage = `Failed to save document: ${error.message}`;
    });
  }

  goBack(): void {
    this.router.navigate(['/legal/ai-assistant/document-generation/templates']);
  }

  getFormattedContent(): string {
    if (!this.documentContent) return '';
    
    let content = this.documentContent;
    let formattedHtml = '<div class="legal-document">';
    let paragraphNumber = 1;
    
    // Extract court header and case caption first
    const courtHeaderPattern = /(COMMONWEALTH OF MASSACHUSETTS.*?CIVIL ACTION)/i;
    const courtMatch = content.match(courtHeaderPattern);
    if (courtMatch) {
      const headerText = courtMatch[0].replace(/\*/g, '');
      formattedHtml += `<div class="court-header">${headerText}</div>`;
      content = content.replace(courtMatch[0], '');
    }
    
    // Extract case number separately
    const caseNumberPattern = /(Case No\.|Civil Action No\.)\s*([A-Z0-9-]+)/i;
    const caseNumMatch = content.match(caseNumberPattern);
    if (caseNumMatch) {
      formattedHtml += `<div class="case-number-line">${caseNumMatch[0]}</div>`;
      content = content.replace(caseNumMatch[0], '');
    }
    
    // Extract party names with proper formatting
    const partyPattern = /\*\*([^*]+)\*\*.*?(Plaintiff|PLAINTIFF).*?v\.?.*?(Defendant|DEFENDANT)/is;
    const partyMatch = content.match(partyPattern);
    if (partyMatch) {
      const plaintiff = partyMatch[1].trim();
      formattedHtml += `
        <div class="party-section">
          <div class="party-line">
            <span class="party-name">${plaintiff},</span>
          </div>
          <div class="party-designation-line">
            <span class="party-designation">Plaintiff,</span>
          </div>
          <div class="versus-line">v.</div>
          <div class="party-line">
            <span class="party-name">[Defendant Name],</span>
          </div>
          <div class="party-designation-line">
            <span class="party-designation">Defendant.</span>
          </div>
        </div>
      `;
      content = content.replace(partyMatch[0], '');
    }
    
    // Extract document title
    const titlePattern = /(COMPLAINT FOR.*?)(?=NOW COMES|PARTIES|\d+\.)/i;
    const titleMatch = content.match(titlePattern);
    if (titleMatch) {
      formattedHtml += `<div class="document-title">${titleMatch[1].trim()}</div>`;
      content = content.replace(titleMatch[0], '');
    }
    
    // Now process the main content with proper paragraph breaks
    // First, add line breaks at key points
    content = content
      // Break before section titles
      .replace(/(PARTIES|JURISDICTION AND VENUE|FACTUAL ALLEGATIONS|COUNT [IVX]+|DAMAGES|WHEREFORE|JURY TRIAL DEMANDED|CERTIFICATE OF SERVICE)/g, '\n\n###SECTION###$1###/SECTION###\n\n')
      // Break before numbered items
      .replace(/([.!?])\s+(\d+\.)\s+/g, '$1\n\n$2 ')
      // Break at "NOW COMES"
      .replace(/(NOW COMES)/g, '\n\n$1')
      // Break at major sentence boundaries
      .replace(/([.!?])\s+([A-Z][a-z])/g, '$1\n\n$2');
    
    // Split into lines for processing
    const lines = content.split(/\n+/);
    let currentSection = '';
    let shouldNumber = false;
    
    lines.forEach(line => {
      line = line.trim();
      if (!line || line.length < 10) return;
      
      // Check for section headers
      if (line.includes('###SECTION###')) {
        const sectionName = line.replace(/###SECTION###|###\/SECTION###/g, '').trim();
        currentSection = sectionName;
        formattedHtml += `<div class="section-heading">${sectionName}</div>`;
        
        // Determine if this section should have numbered paragraphs
        shouldNumber = ['PARTIES', 'JURISDICTION AND VENUE', 'FACTUAL ALLEGATIONS'].includes(sectionName) ||
                      sectionName.startsWith('COUNT');
        
        // Reset paragraph counter for new sections
        if (shouldNumber) paragraphNumber = 1;
        return;
      }
      
      // Check for "NOW COMES" intro (not numbered)
      if (line.startsWith('NOW COMES')) {
        formattedHtml += `<p class="intro-paragraph">${line}</p>`;
        return;
      }
      
      // Check for WHEREFORE clause (special formatting)
      if (line.startsWith('WHEREFORE') || currentSection === 'WHEREFORE') {
        formattedHtml += `<p class="wherefore-clause">${line}</p>`;
        return;
      }
      
      // Check if line already has numbering
      const existingNumbered = line.match(/^(\d+)\.\s+(.+)/);
      if (existingNumbered) {
        const num = existingNumbered[1];
        const text = existingNumbered[2];
        formattedHtml += `
          <div class="numbered-paragraph">
            <span class="paragraph-num">${num}.</span>
            <span class="paragraph-text">${text}</span>
          </div>`;
        paragraphNumber = parseInt(num) + 1;
        return;
      }
      
      // Check for lettered sub-items
      const letteredItem = line.match(/^([a-z])\.\s+(.+)/);
      if (letteredItem) {
        formattedHtml += `
          <div class="lettered-paragraph">
            <span class="paragraph-letter">${letteredItem[1]}.</span>
            <span class="paragraph-text">${letteredItem[2]}</span>
          </div>`;
        return;
      }
      
      // Regular paragraphs - number them if in appropriate section
      if (shouldNumber && line.length > 30) {
        formattedHtml += `
          <div class="numbered-paragraph">
            <span class="paragraph-num">${paragraphNumber}.</span>
            <span class="paragraph-text">${line}</span>
          </div>`;
        paragraphNumber++;
      } else if (line.length > 20) {
        // Non-numbered paragraphs
        formattedHtml += `<p class="regular-text">${line}</p>`;
      }
    });
    
    formattedHtml += '</div>';
    
    // Clean up formatting
    formattedHtml = formattedHtml
      .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
      .replace(/\*([^*]+)\*/g, '<em>$1</em>')
      .replace(/###SECTION###|###\/SECTION###/g, '')
      .replace(/\s{2,}/g, ' ')
      .replace(/<\/div>\s*<div/g, '</div><div');
    
    return formattedHtml;
  }

  toggleEdit(): void {
    this.isEditing = !this.isEditing;
  }

  loadAvailableCases(): void {
    const token = localStorage.getItem(Key.TOKEN);

    fetch('http://localhost:8085/legal-case/list?page=0&size=20', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': token ? `Bearer ${token}` : ''
      }
    })
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      // Transform backend data to match component interface
      if (data.data && data.data.cases && Array.isArray(data.data.cases)) {
        this.availableCases = data.data.cases.map((caseData: any) => ({
          id: caseData.id.toString(),
          clientName: caseData.clientName,
          caseNumber: caseData.caseNumber,
          caseType: caseData.type || 'General Legal'
        }));
      } else {
        console.error('Unexpected data structure:', data);
        this.errorMessage = 'Failed to load cases: Unexpected data format';
        this.availableCases = [];
      }
    })
    .catch(error => {
      console.error('Error loading cases from backend:', error);
      this.errorMessage = `Failed to load cases: ${error.message}. Please ensure backend is running on port 8085 and you are logged in.`;
      this.availableCases = [];
    });
  }

  getSelectedCase(): any {
    return this.availableCases.find(c => c.id === this.selectedCaseId);
  }

  private getValidAuthToken(): string | null {
    const token = localStorage.getItem(Key.TOKEN);

    // Check if token exists and is not a string representation of null/undefined
    if (!token || token === 'null' || token === 'undefined' || token.length < 20) {
      console.warn('⚠️ Invalid or missing authentication token');
      return null;
    }

    // Basic JWT format check (should have 3 parts separated by dots)
    if (token.split('.').length !== 3) {
      console.warn('⚠️ Token does not appear to be a valid JWT format');
      return null;
    }

    return token;
  }

  private createAuthHeaders(token: string): { [key: string]: string } {
    return {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      'Authorization': `Bearer ${token}`
    };
  }

  exportPDF(): void {
    // Create a new window for PDF content
    const printWindow = window.open('', '_blank');
    if (printWindow) {
      const htmlContent = `
        <!DOCTYPE html>
        <html>
          <head>
            <title>Legal Document - Template ${this.templateId}</title>
            <style>
              body { 
                font-family: 'Times New Roman', serif; 
                font-size: 12pt; 
                line-height: 1.6; 
                margin: 1in;
                color: #000;
              }
              h1 { font-size: 18pt; margin-bottom: 20px; text-align: center; }
              h2 { font-size: 16pt; margin: 20px 0 10px; }
              h3 { font-size: 14pt; margin: 15px 0 8px; }
              p { margin-bottom: 12px; }
              strong { font-weight: bold; }
              .page-break { page-break-before: always; }
              @media print {
                body { margin: 0.5in; }
                .no-print { display: none; }
              }
            </style>
          </head>
          <body>
            ${this.getFormattedContent()}
            <script>
              window.onload = function() {
                window.print();
                setTimeout(function() { window.close(); }, 100);
              }
            </script>
          </body>
        </html>
      `;
      
      printWindow.document.write(htmlContent);
      printWindow.document.close();
    } else {
      // Fallback: download as HTML file
      const element = document.createElement('a');
      const file = new Blob([this.getFormattedContent()], { type: 'text/html' });
      element.href = URL.createObjectURL(file);
      element.download = `legal-document-${this.templateId}-${Date.now()}.html`;
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
  }

  exportDOCX(): void {
    // Create RTF format (compatible with Word) instead of plain text
    const rtfHeader = `{\\rtf1\\ansi\\deff0 {\\fonttbl {\\f0 Times New Roman;}} {\\colortbl;\\red0\\green0\\blue0;}`;
    const rtfFooter = `}`;
    
    // Convert markdown-like content to RTF
    let rtfContent = this.documentContent
      .replace(/# (.+)/g, '{\\f0\\fs28\\b $1\\par}')
      .replace(/## (.+)/g, '{\\f0\\fs24\\b $1\\par}')
      .replace(/### (.+)/g, '{\\f0\\fs20\\b $1\\par}')
      .replace(/\*\*(.+?)\*\*/g, '{\\b $1}')
      .replace(/\n/g, '\\par ')
      .replace(/\[([^\]]+)\]/g, '{\\ul $1}'); // Underline placeholder fields
    
    const rtfDocument = `${rtfHeader}
    {\\f0\\fs24 
    ${rtfContent}
    }
    ${rtfFooter}`;
    
    const element = document.createElement('a');
    const file = new Blob([rtfDocument], { type: 'application/rtf' });
    element.href = URL.createObjectURL(file);
    element.download = `legal-document-${this.templateId}-${Date.now()}.rtf`;
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }

  private cleanupPlaceholders(content: string): string {
    // Remove any remaining placeholder brackets to enable export button
    return content
      .replace(/\[([^\]]*)\]/g, '') // Remove empty brackets and their contents
      .replace(/\s{2,}/g, ' ') // Replace multiple spaces with single space
      .trim(); // Remove leading/trailing whitespace
  }

}