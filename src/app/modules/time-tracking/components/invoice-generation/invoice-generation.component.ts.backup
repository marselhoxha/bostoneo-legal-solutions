import { Component, OnInit, OnDestroy, ChangeDetectorRef, ViewChild, ElementRef, AfterViewInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule, ReactiveFormsModule, FormBuilder, FormGroup, Validators, FormArray } from '@angular/forms';
import { RouterModule, Router } from '@angular/router';
import { Subscription, forkJoin, of } from 'rxjs';
import { catchError, finalize, map } from 'rxjs/operators';
import { TimeTrackingService, TimeEntry } from '../../services/time-tracking.service';
import { InvoiceService as TimeTrackingInvoiceService, Invoice as TimeTrackingInvoice } from '../../services/invoice.service';
import { InvoiceService } from '../../../../service/invoice.service';
import { ClientService } from '../../../../service/client.service';
import { LegalCaseService } from '../../../legal/services/legal-case.service';
import { Invoice } from '../../../../interface/invoice';
import { InvoiceLineItem } from '../../../../interface/invoice-line-item';
import Swal from 'sweetalert2';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { saveAs } from 'file-saver';
import { environment } from 'src/environments/environment';
import flatpickr from 'flatpickr';
import { Instance } from 'flatpickr/dist/types/instance';
import { NgSelectModule } from '@ng-select/ng-select';

interface Client {
  id: number;
  name: string;
  email: string;
  type?: string;
  status?: string;
}

interface LegalCase {
  id: number;
  client_id: number;
  case_number: string;
  title: string;
  client_name: string;
  status: string;
}

interface User {
  id: number;
  name: string;
  email: string;
  firstName?: string;
  lastName?: string;
}

@Component({
  selector: 'app-invoice-generation',
  standalone: true,
  imports: [CommonModule, RouterModule, FormsModule, ReactiveFormsModule, NgSelectModule],
  templateUrl: './invoice-generation.component.html',
  styleUrls: ['./invoice-generation.component.scss']
})
export class InvoiceGenerationComponent implements OnInit, OnDestroy, AfterViewInit {
  @ViewChild('issueDatePicker') issueDatePicker!: ElementRef;
  @ViewChild('dueDatePicker') dueDatePicker!: ElementRef;
  
  // Form and data
  invoiceForm: FormGroup;
  timeEntries: TimeEntry[] = [];
  clients: Client[] = [];
  cases: LegalCase[] = [];
  filteredCases: LegalCase[] = [];
  users: User[] = [];
  selectedEntries: Set<number> = new Set();
  
  // UI state
  loading = false;
  loadingClients = false;
  loadingCases = false;
  isGenerating = false;
  error: string | null = null;
  
  // Invoice preview data
  previewData = {
    subtotal: 0,
    taxAmount: 0,
    totalAmount: 0,
    selectedEntriesCount: 0
  };
  
  // Generated invoice
  generatedInvoice: Invoice | null = null;
  
  // Date pickers
  private issueDatePickerInstance: Instance | null = null;
  private dueDatePickerInstance: Instance | null = null;
  
  // Statuses for invoice
  statuses = ['DRAFT', 'PENDING', 'PAID', 'OVERDUE', 'CANCELLED'];
  
  private subscriptions: Subscription[] = [];

  constructor(
    private fb: FormBuilder,
    private timeTrackingService: TimeTrackingService,
    private timeTrackingInvoiceService: TimeTrackingInvoiceService,
    private invoiceService: InvoiceService,
    private clientService: ClientService,
    private legalCaseService: LegalCaseService,
    private http: HttpClient,
    private router: Router,
    private cdr: ChangeDetectorRef
  ) {
    this.initializeForm();
  }

  ngOnInit(): void {
    this.checkAuthentication();
    this.loadClients();
    this.loadUsers();
    this.setupFormListeners();
  }

  ngAfterViewInit(): void {
    this.setupDatePickers();
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach(sub => sub.unsubscribe());
    if (this.issueDatePickerInstance) {
      this.issueDatePickerInstance.destroy();
    }
    if (this.dueDatePickerInstance) {
      this.dueDatePickerInstance.destroy();
    }
  }

  private initializeForm(): void {
    const today = new Date();
    const dueDate = new Date();
    dueDate.setDate(dueDate.getDate() + 30); // 30 days from now

    this.invoiceForm = this.fb.group({
      clientId: ['', Validators.required],
      legalCaseId: [''],
      issueDate: [today.toISOString().split('T')[0], Validators.required],
      dueDate: [dueDate.toISOString().split('T')[0], Validators.required],
      subtotal: [0, [Validators.required, Validators.min(0)]],
      taxRate: [0, [Validators.min(0), Validators.max(100)]],
      taxAmount: [{value: 0, disabled: true}],
      totalAmount: [{value: 0, disabled: true}],
      status: ['DRAFT', Validators.required],
      notes: [''],
      lineItems: this.fb.array([])
    });

    // Generate invoice number
    this.generateInvoiceNumber();
  }

  private setupDatePickers(): void {
    // Issue date picker
    if (this.issueDatePicker?.nativeElement) {
      this.issueDatePickerInstance = flatpickr(this.issueDatePicker.nativeElement, {
        dateFormat: 'Y-m-d',
        defaultDate: new Date(),
        onChange: (selectedDates) => {
          if (selectedDates.length > 0) {
            this.invoiceForm.patchValue({
              issueDate: selectedDates[0].toISOString().split('T')[0]
            });
          }
        }
      });
    }

    // Due date picker
    if (this.dueDatePicker?.nativeElement) {
      this.dueDatePickerInstance = flatpickr(this.dueDatePicker.nativeElement, {
        dateFormat: 'Y-m-d',
        defaultDate: this.getDefaultDueDate(),
        minDate: new Date(),
        onChange: (selectedDates) => {
          if (selectedDates.length > 0) {
            this.invoiceForm.patchValue({
              dueDate: selectedDates[0].toISOString().split('T')[0]
            });
          }
        }
      });
    }
  }

  private setupFormListeners(): void {
    // Listen for client changes
    const clientSub = this.invoiceForm.get('clientId')?.valueChanges.subscribe(clientId => {
      if (clientId) {
        this.loadCases(clientId);
        this.loadUnbilledEntries(clientId);
        // Clear existing selections when client changes
        this.selectedEntries.clear();
        this.updatePreviewData();
      } else {
        this.filteredCases = [];
        this.timeEntries = [];
        this.selectedEntries.clear();
        this.updatePreviewData();
      }
    });

    // Listen for case changes
    const caseSub = this.invoiceForm.get('legalCaseId')?.valueChanges.subscribe(caseId => {
      const clientId = this.invoiceForm.get('clientId')?.value;
      if (clientId) {
        this.loadUnbilledEntries(clientId, caseId);
      }
    });

    // Listen for tax rate changes
    const taxSub = this.invoiceForm.get('taxRate')?.valueChanges.subscribe(() => {
      this.updatePreviewData();
    });

    this.subscriptions.push(clientSub, caseSub, taxSub);
  }

  private loadClients(): void {
    this.loadingClients = true;
    console.log('Loading clients for invoice generation...');
    
    // Use TimeTrackingService which has better error handling
    const clientSub = this.timeTrackingService.getClients().subscribe({
      next: (clients) => {
        console.log('Clients loaded successfully:', clients.length, 'clients');
        this.clients = clients || [];
        this.loadingClients = false;
        this.cdr.detectChanges();
      },
      error: (error) => {
        console.error('Error loading clients:', error);
        this.clients = [];
        this.loadingClients = false;
        this.cdr.detectChanges();
      }
    });
    this.subscriptions.push(clientSub);
  }

  private loadUsers(): void {
    // Load users for time entry attribution
    const userSub = this.http.get<any>(`${environment.apiUrl}/api/users`).subscribe({
      next: (response) => {
        if (response?.data) {
          this.users = Array.isArray(response.data) ? response.data : response.data.content || [];
        }
        this.cdr.detectChanges();
      },
      error: (error) => {
        console.error('Error loading users:', error);
      }
    });
    this.subscriptions.push(userSub);
  }

  private loadCases(clientId: number): void {
    this.loadingCases = true;
    const caseSub = this.legalCaseService.getCasesByClient(clientId).subscribe({
      next: (response) => {
        if (response?.data) {
          this.filteredCases = Array.isArray(response.data) ? response.data : response.data.content || [];
        }
        this.loadingCases = false;
        this.cdr.detectChanges();
      },
      error: (error) => {
        console.error('Error loading cases:', error);
        this.filteredCases = [];
        this.loadingCases = false;
        this.cdr.detectChanges();
      }
    });
    this.subscriptions.push(caseSub);
  }

  private loadUnbilledEntries(clientId: number, caseId?: number): void {
    this.loading = true;
    const entrySub = this.timeTrackingInvoiceService.getUnbilledTimeEntries(clientId, caseId).subscribe({
      next: (entries: TimeEntry[]) => {
        // The service already returns TimeEntry[], so we can use it directly
        this.timeEntries = entries.filter(entry => {
          const hasNoInvoice = !entry.invoiceId;
          const isBillable = entry.billable !== false;
          const isApproved = entry.status === 'BILLING_APPROVED' || entry.status === 'APPROVED';
          return hasNoInvoice && isBillable && isApproved;
        });
        
        console.log(`Loaded ${this.timeEntries.length} unbilled entries for client ${clientId}`, this.timeEntries);
        this.selectedEntries.clear();
        this.updatePreviewData();
        this.loading = false;
        this.cdr.detectChanges();
      },
      error: (error) => {
        console.error('Error loading unbilled entries:', error);
        this.timeEntries = [];
        this.selectedEntries.clear();
        this.updatePreviewData();
        this.loading = false;
        this.cdr.detectChanges();
      }
    });
    this.subscriptions.push(entrySub);
  }

  // Line Items Management
  get lineItems(): FormArray {
    return this.invoiceForm.get('lineItems') as FormArray;
  }

  addLineItem(): void {
    const lineItem = this.fb.group({
      description: ['', Validators.required],
      quantity: [1, [Validators.required, Validators.min(0.01)]],
      unitPrice: [0, [Validators.required, Validators.min(0)]],
      amount: [{value: 0, disabled: true}],
      category: ['LEGAL'],
      serviceDate: [new Date().toISOString().split('T')[0]]
    });

    // Listen for quantity and unitPrice changes to calculate amount
    lineItem.get('quantity')?.valueChanges.subscribe(() => this.calculateLineItemAmount(lineItem));
    lineItem.get('unitPrice')?.valueChanges.subscribe(() => this.calculateLineItemAmount(lineItem));

    this.lineItems.push(lineItem);
    this.updateTotals();
  }

  removeLineItem(index: number): void {
    this.lineItems.removeAt(index);
    this.updateTotals();
  }

  private calculateLineItemAmount(lineItem: FormGroup): void {
    const quantity = lineItem.get('quantity')?.value || 0;
    const unitPrice = lineItem.get('unitPrice')?.value || 0;
    const amount = quantity * unitPrice;
    lineItem.get('amount')?.setValue(amount);
    this.updateTotals();
  }

  private updateTotals(): void {
    let subtotal = 0;
    
    // Calculate from line items
    this.lineItems.controls.forEach(control => {
      const amount = control.get('amount')?.value || 0;
      subtotal += amount;
    });

    const taxRate = this.invoiceForm.get('taxRate')?.value || 0;
    const taxAmount = subtotal * (taxRate / 100);
    const totalAmount = subtotal + taxAmount;

    this.invoiceForm.patchValue({
      subtotal: subtotal,
      taxAmount: taxAmount,
      totalAmount: totalAmount
    });
  }

  // Time Entry Management
  toggleEntrySelection(entry: TimeEntry): void {
    if (this.selectedEntries.has(entry.id!)) {
      this.selectedEntries.delete(entry.id!);
    } else {
      this.selectedEntries.add(entry.id!);
    }
    this.updatePreviewData();
    this.generateLineItemsFromTimeEntries();
  }

  selectAll(): void {
    this.timeEntries.forEach(entry => {
      if (entry.id) {
        this.selectedEntries.add(entry.id);
      }
    });
    this.updatePreviewData();
    this.generateLineItemsFromTimeEntries();
  }

  deselectAll(): void {
    this.selectedEntries.clear();
    this.updatePreviewData();
    this.clearLineItems();
  }

  private generateLineItemsFromTimeEntries(): void {
    // Clear existing line items
    this.clearLineItems();
    
    // Get selected time entries
    const selectedTimeEntries = this.timeEntries.filter(entry => entry.id && this.selectedEntries.has(entry.id));
    
    // Create individual line items for each time entry to preserve descriptions
    selectedTimeEntries.forEach(entry => {
      const lineItem = this.fb.group({
        description: [entry.description || 'Legal Services', Validators.required],
        quantity: [entry.hours, [Validators.required, Validators.min(0.01)]],
        unitPrice: [entry.rate, [Validators.required, Validators.min(0)]],
        amount: [{value: entry.hours * entry.rate, disabled: true}],
        category: ['LEGAL'],
        serviceDate: [entry.date]
      });

      // Listen for changes
      lineItem.get('quantity')?.valueChanges.subscribe(() => this.calculateLineItemAmount(lineItem));
      lineItem.get('unitPrice')?.valueChanges.subscribe(() => this.calculateLineItemAmount(lineItem));

      this.lineItems.push(lineItem);
    });
    
    this.updateTotals();
  }

  private clearLineItems(): void {
    while (this.lineItems.length !== 0) {
      this.lineItems.removeAt(0);
    }
    this.updateTotals();
  }

  private updatePreviewData(): void {
    const selectedTimeEntries = this.timeEntries.filter(entry => entry.id && this.selectedEntries.has(entry.id));
    
    let subtotal = 0;
    selectedTimeEntries.forEach(entry => {
      subtotal += entry.hours * entry.rate;
    });

    const taxRate = this.invoiceForm.get('taxRate')?.value || 0;
    const taxAmount = subtotal * (taxRate / 100);
    const totalAmount = subtotal + taxAmount;

    this.previewData = {
      subtotal,
      taxAmount,
      totalAmount,
      selectedEntriesCount: this.selectedEntries.size
    };
  }

  // Invoice Generation
    generateInvoice(): void {
      return;
    }

    // Check if there are items to invoice
    if (this.selectedEntries.size === 0 && this.lineItems.length === 0) {
      Swal.fire({
        title: 'No Items Selected',
        text: 'Please select time entries or add line items to generate an invoice.',
        icon: 'warning'
      });
      return;
    }

    this.isGenerating = true;
    const formValue = this.invoiceForm.value;
    
    // Get selected client and case information
    const client = this.clients.find(c => c.id === Number(formValue.clientId));
    const legalCase = this.filteredCases.find(c => c.id === formValue.legalCaseId);

    // Create base invoice object
    const baseInvoice = {
      clientId: formValue.clientId,
      clientName: client?.name || '',
      legalCaseId: formValue.legalCaseId || null,
      caseName: legalCase?.title || null,
      issueDate: formValue.issueDate,
      dueDate: formValue.dueDate,
      taxRate: formValue.taxRate,
      status: formValue.status,
      notes: formValue.notes
    };

    // Check if we have selected time entries
    if (this.selectedEntries.size > 0) {
      // Use the new endpoint for time entries
      console.log('Creating invoice from time entries:', Array.from(this.selectedEntries));
      
      this.invoiceService.createInvoiceFromTimeEntries(baseInvoice, Array.from(this.selectedEntries)).subscribe({
        next: (response) => {
          this.isGenerating = false;
          this.generatedInvoice = response;
          
          // Clear selected entries since they're now invoiced
          this.selectedEntries.clear();
          
          // Refresh the unbilled entries list
          const currentClientId = this.invoiceForm.get('clientId')?.value;
          const currentCaseId = this.invoiceForm.get('legalCaseId')?.value;
          if (currentClientId) {
            this.loadUnbilledEntries(currentClientId, currentCaseId);
          }
          
          this.cdr.detectChanges();
          
          Swal.fire({
            title: 'Success!',
            text: 'Invoice created successfully from time entries',
            icon: 'success',
            showCancelButton: true,
            confirmButtonText: 'Download PDF',
            cancelButtonText: 'View Invoice',
            reverseButtons: true
          }).then((result) => {
            if (result.isConfirmed) {
              this.downloadPdf();
            } else if (result.dismiss === Swal.DismissReason.cancel) {
              this.router.navigate(['/invoices', response.id, response.invoiceNumber]);
            }
          });
        },
        error: (error) => {
          this.isGenerating = false;
          console.error('Invoice creation error:', error);
          Swal.fire({
            title: 'Error!',
            text: error.message || 'Failed to create invoice from time entries',
            icon: 'error'
          });
        }
      });
    } else {
      // Use the old endpoint for manual line items
      console.log('Creating invoice from manual line items');
      
      const invoice = {
        ...baseInvoice,
        subtotal: formValue.subtotal,
        taxAmount: formValue.taxAmount,
        totalAmount: formValue.totalAmount,
        lineItems: formValue.lineItems.map((item: any) => ({
          description: item.description,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          amount: item.quantity * item.unitPrice,
          category: item.category,
          serviceDate: item.serviceDate
        }))
      };

      this.invoiceService.createInvoice(invoice).subscribe({
        next: (response) => {
          this.isGenerating = false;
          this.generatedInvoice = response;
          
          Swal.fire({
            title: 'Success!',
            text: 'Invoice created successfully',
            icon: 'success',
            showCancelButton: true,
            confirmButtonText: 'Download PDF',
            cancelButtonText: 'View Invoice',
            reverseButtons: true
          }).then((result) => {
            if (result.isConfirmed) {
              this.downloadPdf();
            } else if (result.dismiss === Swal.DismissReason.cancel) {
              this.router.navigate(['/invoices', response.id, response.invoiceNumber]);
            }
          });
        },
        error: (error) => {
          this.isGenerating = false;
          console.error('Invoice creation error:', error);
          Swal.fire({
            title: 'Error!',
            text: error.message || 'Failed to create invoice',
            icon: 'error'
          });
        }
      });
    }
  });
      return;
    }

    this.isGenerating = true;
    const formValue = this.invoiceForm.value;
    
    // Get selected client and case information
    const client = this.clients.find(c => c.id === Number(formValue.clientId));
    const legalCase = this.filteredCases.find(c => c.id === formValue.legalCaseId);

    // Create base invoice object
    const baseInvoice = {
      clientId: formValue.clientId,
      clientName: client?.name || '',
      legalCaseId: formValue.legalCaseId || null,
      caseName: legalCase?.title || null,
      issueDate: formValue.issueDate,
      dueDate: formValue.dueDate,
      taxRate: formValue.taxRate,
      status: formValue.status,
      notes: formValue.notes
    };

    // Check if we have selected time entries
    if (this.selectedEntries.size > 0) {
      // Use the new endpoint for time entries
      console.log('Creating invoice from time entries:', Array.from(this.selectedEntries));
      
      this.invoiceService.createInvoiceFromTimeEntries(baseInvoice, Array.from(this.selectedEntries)).subscribe({
        next: (response) => {
          this.isGenerating = false;
          this.generatedInvoice = response;
          
          // Clear selected entries since they're now invoiced
          this.selectedEntries.clear();
          
          // Refresh the unbilled entries list
          const currentClientId = this.invoiceForm.get('clientId')?.value;
          const currentCaseId = this.invoiceForm.get('legalCaseId')?.value;
          if (currentClientId) {
            this.loadUnbilledEntries(currentClientId, currentCaseId);
          }
          
          this.cdr.detectChanges();
          
          Swal.fire({
            title: 'Success!',
            text: 'Invoice created successfully from time entries',
            icon: 'success',
            showCancelButton: true,
            confirmButtonText: 'Download PDF',
            cancelButtonText: 'View Invoice',
            reverseButtons: true
          }).then((result) => {
            if (result.isConfirmed) {
              this.downloadPdf();
            } else if (result.dismiss === Swal.DismissReason.cancel) {
              this.router.navigate(['/invoices', response.id, response.invoiceNumber]);
            }
          });
        },
        error: (error) => {
          this.isGenerating = false;
          console.error('Invoice creation error:', error);
          Swal.fire({
            title: 'Error!',
            text: error.message || 'Failed to create invoice from time entries',
            icon: 'error'
          });
        }
      });
    } else {
      // Use the old endpoint for manual line items
      console.log('Creating invoice from manual line items');
      
      const invoice = {
        ...baseInvoice,
        subtotal: formValue.subtotal,
        taxAmount: formValue.taxAmount,
        totalAmount: formValue.totalAmount,
        lineItems: formValue.lineItems.map((item: any) => ({
          description: item.description,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          amount: item.quantity * item.unitPrice,
          category: item.category,
          serviceDate: item.serviceDate
        }))
      };

      this.invoiceService.createInvoice(invoice).subscribe({
        next: (response) => {
          this.isGenerating = false;
          this.generatedInvoice = response;
          
          Swal.fire({
            title: 'Success!',
            text: 'Invoice created successfully',
            icon: 'success',
            showCancelButton: true,
            confirmButtonText: 'Download PDF',
            cancelButtonText: 'View Invoice',
            reverseButtons: true
          }).then((result) => {
            if (result.isConfirmed) {
              this.downloadPdf();
            } else if (result.dismiss === Swal.DismissReason.cancel) {
              this.router.navigate(['/invoices', response.id, response.invoiceNumber]);
            }
          });
        },
        error: (error) => {
          this.isGenerating = false;
          console.error('Invoice creation error:', error);
          Swal.fire({
            title: 'Error!',
            text: error.message || 'Failed to create invoice',
            icon: 'error'
          });
        }
      });
    }
  },
        error: (error) => {
          this.isGenerating = false;
          console.error('Invoice creation error:', error);
          Swal.fire({
            title: 'Error!',
            text: error.message || 'Failed to create invoice',
            icon: 'error'
          });
        }
      });
    }
  }

  downloadPdf(): void {
    if (!this.generatedInvoice?.id) {
      Swal.fire({
        title: 'Error!',
        text: 'No invoice available for download',
        icon: 'error'
      });
      return;
    }

    this.invoiceService.generateInvoicePdf(this.generatedInvoice.id).subscribe({
      next: (blob: Blob) => {
        saveAs(blob, `invoice-${this.generatedInvoice!.invoiceNumber}.pdf`);
        Swal.fire({
          title: 'Success!',
          text: 'Invoice PDF downloaded successfully',
          icon: 'success',
          timer: 2000,
          showConfirmButton: false
        });
      },
      error: (error) => {
        console.error('Error downloading PDF:', error);
        Swal.fire({
          title: 'Error!',
          text: 'Failed to download PDF. Please try again.',
          icon: 'error'
        });
      }
    });
  }

  private validateForm(): boolean {
    if (this.invoiceForm.invalid) {
      Object.keys(this.invoiceForm.controls).forEach(key => {
        const control = this.invoiceForm.get(key);
        if (control?.invalid) {
          control.markAsTouched();
        }
      });
      
      Swal.fire({
        title: 'Form Invalid',
        text: 'Please fill in all required fields.',
        icon: 'warning'
      });
      return false;
    }
    return true;
  }

  onCancel(): void {
    this.router.navigate(['/time-tracking/billing']);
  }

  // Utility Methods
  getTotalUnbilledHours(): number {
    return this.timeEntries.reduce((total, entry) => total + entry.hours, 0);
  }

  getTotalSelectedHours(): number {
    return this.timeEntries
      .filter(entry => entry.id && this.selectedEntries.has(entry.id))
      .reduce((total, entry) => total + entry.hours, 0);
  }

  trackByEntryId(index: number, entry: TimeEntry): number {
    return entry.id || index;
  }

  generateInvoiceNumber(): string {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const time = String(now.getHours()).padStart(2, '0') + String(now.getMinutes()).padStart(2, '0');
    return `INV-${year}${month}${day}-${time}`;
  }

  getSelectedClientName(): string {
    const clientId = this.invoiceForm.get('clientId')?.value;
    const client = this.clients.find(c => c.id === Number(clientId));
    return client?.name || '';
  }

  getSelectedClientEmail(): string {
    const clientId = this.invoiceForm.get('clientId')?.value;
    const client = this.clients.find(c => c.id === Number(clientId));
    return client?.email || '';
  }

  getSelectedCaseName(): string {
    const caseId = this.invoiceForm.get('legalCaseId')?.value;
    const legalCase = this.filteredCases.find(c => c.id === caseId);
    return legalCase?.title || '';
  }

  getUserName(userId: number): string {
    const user = this.users.find(u => u.id === userId);
    if (user) {
      return user.firstName && user.lastName 
        ? `${user.firstName} ${user.lastName}`
        : user.name || user.email || `User ${userId}`;
    }
    return `User ${userId}`;
  }

  getStatusLabel(status: string): string {
    const statusLabels: { [key: string]: string } = {
      'BILLING_APPROVED': 'Approved for Billing',
      'APPROVED': 'Approved',
      'PENDING': 'Pending Review',
      'DRAFT': 'Draft',
      'REJECTED': 'Rejected'
    };
    return statusLabels[status] || status;
  }

  private getDefaultDueDate(): string {
    const date = new Date();
    date.setDate(date.getDate() + 30);
    return date.toISOString().split('T')[0];
  }

  private checkAuthentication(): void {
    // Temporarily disabled for testing - uncomment for production
    /*
    const token = localStorage.getItem('TOKEN');
    if (!token) {
      console.warn('No authentication token found. Please log in.');
      this.error = 'Authentication required. Please log in to continue.';
      return;
    }

    // Check if token has proper JWT format (3 parts)
    const tokenParts = token.split('.');
    if (tokenParts.length !== 3) {
      console.error('Invalid JWT token format. Token has', tokenParts.length, 'parts, expected 3.');
      this.error = 'Invalid authentication token. Please log out and log in again.';
      localStorage.removeItem('TOKEN');
      localStorage.removeItem('REFRESH_TOKEN');
      return;
    }
    */

    console.log('Authentication check bypassed for testing');
  }
}






